

////////////////////////////////////////////////
//               MODFICACION_                //
////////////////////////////////////////////////

//suma los valores de las posiciones de indices pares del vectorsparse, y lo pone en un vector, y las impares en otra posicion

sparse_vector_t sparse_vector_t::par_impar(){
  vector_t<double> sp_v(2); // crea un sparse vector de dos elementos a 0 
  for (int i = 0; i < get_nz(); ++i){ //recorremos el vector
    if (at(i).get_inx() % 2 == 0){ //si resulta que el indice de la posicion es PAR
      sp_v.at(0) += at(i).get_val();  //sumamos a el primer elemento su valor
    } else {              //si no, quiere decir que es impar
      sp_v.at(1) += at(i).get_val();  //sumamos a el segundo elemento el valor
    }
  }
  sparse_vector_t vec_fin(sp_v); //lo guardamos en un sparse vector
  return vec_fin; //y lo retornamos
}

//sacar los valores de los elementos con grado par
sparse_vector_t sparse_vector_t::ElementosPares(){
  vector_t<double> sp_v(get_nz() / 2);
  int j = 0;
  for (int i = 0; i < get_nz(); ++i){
    if (at(i).get_inx() % 2 == 0){
      sp_v.at(j) += at(i).get_val(); 
      j++;
    } 
  }
  sparse_vector_t vec_fin(sp_v);
  return vec_fin;
}

//sumar los coeficioentes de un sparse polinomial

double sparse_vector_t::SumaCoeficientes() const {
  double suma{0.0}; // inicializamos la variable suma en cero
  for (int i = 0; i < get_nz(); ++i){ // recorremos el vector sparse
    suma += at(i).get_val(); // sumamos el valor de cada elemento a la variable suma
  }
  return suma; // retornamos el valor de la suma
}

//mostrar por pantalla los numeros de un vector disperso que su indice sea mayor que un nÃºmero dado, es decir 23456, si le dices 3, el vector es 456
void sparse_vector_t::IndicesMayoresQue(const int x) const {

  for (int i = 0; i<get_nz() ; i++){
    if (at(i).get_inx() > x){
      std::cout << at(i).get_val() << " " ;
    }
  }
  std::cout << std::endl;
}

//imprimir el monomio de mayor y menor grado de un sparse polinomial
sparse_vector_t sparse_vector_t::MayorMenor(){
  vector_t<double> sp_v(2); // crea un sparse vector de dos elementos a 0 
  int j = 0;
  for (int i = 0; i < get_nz(); i+= get_nz()- 1){ //recorremos el vector
      sp_v.at(j) += at(i).get_val();  // guardamos en la posicion 0, el primero y en 1 el ultimo
      j++;
  }
  sparse_vector_t vec_fin(sp_v); //lo guardamos en un sparse vector
  return vec_fin; //y lo retornamos
}

//Sumar el valor de los exponentes de un sparse polinomial

int sparse_vector_t::SumaInx() const {
  int suma{0}; // inicializamos la variable suma en cero 
  for (int i = 0; i < get_nz(); ++i){ // recorremos el vector sparse
    suma += at(i).get_inx(); // sumamos el valor de cada indices del elemento
  }
  return suma; // retornamos el valor de la suma
}

//imprimir solo los monomios de indices consecutivos

void MonomiosConsecutivos ( const sparse_vector_t& spol) { //se le pasa por parametro el polinomio a analizar
  for (int i = 0; i < spol.get_nz() -1; i++ ) { //recorremos el polinomio
    if( (spol.at(i+1).get_inx() - spol.at(i).get_inx()) == 1){  //si el indice de la funcion sigiente menos el anterior es 1 ( osea es consecutivo )
    // diremos el par de polinomios con indice consecutivo con el cout
      std::cout << spol.at(i).get_val() << "x^" << spol.at(i).get_inx() << " y " << spol.at(i +1).get_val() << "x^" << spol.at(i+1).get_inx() << std::endl; 
    }
  }

}